# Write-Up : Client-side-again 
---
### Description :
> Can you break into this super secure portal? https://jupiter.challenges.picoctf.org/problem/60786/ (link) or http://jupiter.challenges.picoctf.org:60786
### Hint :
> What is obfuscation?
---
### Solution :
- Sau khi vào trang web ta thấy trang web yêu cầu ta nhập mật khẩu, bấm `` f12 `` để xem phần source.
  ![](../img/Client-side-again-source.png)

Ta thấy được có 1 đoạn `` JavaScript `` :
```html
<script type="text/javascript" src="md5.js"></script>

<script type="text/javascript">
  var _0x5a46=['f49bf}','_again_e','this','Password\x20Verified','Incorrect\x20password','getElementById','value','substring','picoCTF{','not_this'];(function(_0x4bd822,_0x2bd6f7){var _0xb4bdb3=function(_0x1d68f6){while(--_0x1d68f6){_0x4bd822['push'](_0x4bd822['shift']());}};_0xb4bdb3(++_0x2bd6f7);}(_0x5a46,0x1b3));var _0x4b5b=function(_0x2d8f05,_0x4b81bb){_0x2d8f05=_0x2d8f05-0x0;var _0x4d74cb=_0x5a46[_0x2d8f05];return _0x4d74cb;};function verify(){checkpass=document[_0x4b5b('0x0')]('pass')[_0x4b5b('0x1')];split=0x4;if(checkpass[_0x4b5b('0x2')](0x0,split*0x2)==_0x4b5b('0x3')){if(checkpass[_0x4b5b('0x2')](0x7,0x9)=='{n'){if(checkpass[_0x4b5b('0x2')](split*0x2,split*0x2*0x2)==_0x4b5b('0x4')){if(checkpass[_0x4b5b('0x2')](0x3,0x6)=='oCT'){if(checkpass[_0x4b5b('0x2')](split*0x3*0x2,split*0x4*0x2)==_0x4b5b('0x5')){if(checkpass['substring'](0x6,0xb)=='F{not'){if(checkpass[_0x4b5b('0x2')](split*0x2*0x2,split*0x3*0x2)==_0x4b5b('0x6')){if(checkpass[_0x4b5b('0x2')](0xc,0x10)==_0x4b5b('0x7')){alert(_0x4b5b('0x8'));}}}}}}}}else{alert(_0x4b5b('0x9'));}}
</script>
```
Khá là rối mắt!!!
- Dùng tool `` https://unminify.com/ `` để dễ nhìn hơn.
```html
  <script type="text/javascript" src="md5.js"></script>

<script type="text/javascript">
    var _0x5a46 = ["f49bf}", "_again_e", "this", "Password\x20Verified", "Incorrect\x20password", "getElementById", "value", "substring", "picoCTF{", "not_this"];
    (function (_0x4bd822, _0x2bd6f7) {
        var _0xb4bdb3 = function (_0x1d68f6) {
            while (--_0x1d68f6) {
                _0x4bd822["push"](_0x4bd822["shift"]());
            }
        };
        _0xb4bdb3(++_0x2bd6f7);
    })(_0x5a46, 0x1b3);
    var _0x4b5b = function (_0x2d8f05, _0x4b81bb) {
        _0x2d8f05 = _0x2d8f05 - 0x0;
        var _0x4d74cb = _0x5a46[_0x2d8f05];
        return _0x4d74cb;
    };
    function verify() {
        checkpass = document[_0x4b5b("0x0")]("pass")[_0x4b5b("0x1")];
        split = 0x4;
        if (checkpass[_0x4b5b("0x2")](0x0, split * 0x2) == _0x4b5b("0x3")) {
            if (checkpass[_0x4b5b("0x2")](0x7, 0x9) == "{n") {
                if (checkpass[_0x4b5b("0x2")](split * 0x2, split * 0x2 * 0x2) == _0x4b5b("0x4")) {
                    if (checkpass[_0x4b5b("0x2")](0x3, 0x6) == "oCT") {
                        if (checkpass[_0x4b5b("0x2")](split * 0x3 * 0x2, split * 0x4 * 0x2) == _0x4b5b("0x5")) {
                            if (checkpass["substring"](0x6, 0xb) == "F{not") {
                                if (checkpass[_0x4b5b("0x2")](split * 0x2 * 0x2, split * 0x3 * 0x2) == _0x4b5b("0x6")) {
                                    if (checkpass[_0x4b5b("0x2")](0xc, 0x10) == _0x4b5b("0x7")) {
                                        alert(_0x4b5b("0x8"));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            alert(_0x4b5b("0x9"));
        }
    }
</script>
```
Theo hint của bài thì nó đã bị `làm rối (obfuscate)`.
#### Việc của ta là dịch ngược (reverse engineer) nó lại và có được flag: 
- Có 1 cái exploit dùng python được 1 anh nước ngoài viết để giải quyết bài này, code ở dưới :
```python
def reverse_deobfuscate_flag():
    # Original obfuscated array from the JS code
    arr = [
        "37115}",
        "_again_3",
        "this",
        "Password Verified",
        "Incorrect password",
        "getElementById",
        "value",
        "substring",
        "picoCTF{",
        "not_this"
    ]
    # The JS IIFE rotates the array 435 times.
    # Since 435 mod len(arr)=435 mod 10 = 5, the array is rotated 5 times.
    rotations = 435 % len(arr)
    rotated = arr[rotations:] + arr[:rotations]

    # Define the mapping function _0x4b5b as in the JS code.
    # It converts a hexadecimal string to an integer and returns the corresponding rotated array element.
    def _0x4b5b(idx):
        if isinstance(idx, str):
            idx = int(idx, 16)
        return rotated[idx]

    # The JS code uses these mappings:
    # _0x4b5b("0x3") -> "picoCTF{"
    # _0x4b5b("0x4") -> "not_this"
    # _0x4b5b("0x6") -> "_again_3"
    # _0x4b5b("0x5") -> "37115}"
    # _0x4b5b("0x7") -> "this"
    seg1 = _0x4b5b("0x3")  # "picoCTF{"
    seg2 = _0x4b5b("0x4")  # "not_this"
    seg3 = _0x4b5b("0x6")  # "_again_3"
    seg4 = _0x4b5b("0x5")  # "37115}"
    seg7 = _0x4b5b("0x7")  # "this"

    # In addition, the verification uses some literal strings:
    # "oCT", "F{not", and "{n"
    #
    # According to the JS, the flag (checkpass) must satisfy:
    #   1. checkpass[0:8]   == seg1           ("picoCTF{")
    #   2. checkpass[7:9]   == "{n"
    #   3. checkpass[8:16]  == seg2           ("not_this")
    #   4. checkpass[3:6]   == "oCT"
    #   5. checkpass[24:32] == seg4           ("37115}")  [Since our candidate ends at index 29, this means indices 24-29]
    #   6. checkpass[6:11]  == "F{not"
    #   7. checkpass[16:24] == seg3           ("_again_3")
    #   8. checkpass[12:16] == seg7           ("this")
    #
    # We will “reverse” these constraints by starting with an empty candidate
    # list of 30 characters (the flag length deduced from the segments) and then filling in each part.

    flag = [None] * 30  # Create a list for 30 characters

    # Condition 1: indices 0 to 7 must equal seg1 ("picoCTF{")
    for i, c in enumerate(seg1):
        flag[i] = c

    # Condition 6: indices 6 to 10 must equal "F{not"
    for i, c in enumerate("F{not"):
        flag[6 + i] = c

    # Condition 2: indices 7 to 9 must equal "{n"
    flag[7] = '{'  # already set by seg1 but we enforce it
    flag[8] = 'n'

    # Condition 3: indices 8 to 16 must equal seg2 ("not_this")
    for i, c in enumerate(seg2):
        flag[8 + i] = c

    # Condition 4: indices 3 to 6 must equal "oCT"
    for i, c in enumerate("oCT"):
        flag[3 + i] = c

    # Condition 8: indices 12 to 16 must equal seg7 ("this")
    for i, c in enumerate(seg7):
        flag[12 + i] = c

    # Condition 7: indices 16 to 24 must equal seg3 ("_again_3")
    for i, c in enumerate(seg3):
        flag[16 + i] = c

    # Condition 5: indices 24 to 30 must equal seg4 ("37115}")
    for i, c in enumerate(seg4):
        flag[24 + i] = c

    candidate = "".join(flag)

    # Verify that all conditions are met:
    if (candidate[0:8] == seg1 and
        candidate[7:9] == "{n" and
        candidate[8:16] == seg2 and
        candidate[3:6] == "oCT" and
        candidate[24:30] == seg4 and
        candidate[6:11] == "F{not" and
        candidate[16:24] == seg3 and
        candidate[12:16] == seg7):
        return candidate
    else:
        return None

if __name__ == '__main__':
    print("\nFLAG: " + reverse_deobfuscate_flag())
 
```
> Cố gắng đọc hiểu code anh ấy viết gì chứ đừng quá phụ thuộc vào.
- Dùng lệnh ```bash python3 exploit.py ``` để chạy và nhận được flag.
### Flag : `` picoCTF{not_this_again_337115} `` 
